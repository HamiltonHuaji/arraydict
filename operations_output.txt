================================================================================
Case: Basic indexing and batch dimension manipulation
================================================================================

arraydict=ArrayDict({'x': jnp.ones((3, 4, 5)), 'y': jnp.zeros((3, 4))})
ArrayDict(
    fields={
        x: Tensor(shape=(3, 4, 5), dtype=float32),
        y: Tensor(shape=(3, 4), dtype=float32),
    },
    batch_size=(3, 4))

arraydict[0]
ArrayDict(
    fields={
        x: Tensor(shape=(4, 5), dtype=float32),
        y: Tensor(shape=(4,), dtype=float32),
    },
    batch_size=(4,))

arraydict[0][None]
ArrayDict(
    fields={
        x: Tensor(shape=(1, 4, 5), dtype=float32),
        y: Tensor(shape=(1, 4), dtype=float32),
    },
    batch_size=(1, 4))

arraydict[:2]
ArrayDict(
    fields={
        x: Tensor(shape=(2, 4, 5), dtype=float32),
        y: Tensor(shape=(2, 4), dtype=float32),
    },
    batch_size=(2, 4))

arraydict[0, 1]
ArrayDict(
    fields={
        x: Tensor(shape=(5,), dtype=float32),
        y: Tensor(shape=(), dtype=float32),
    },
    batch_size=())

================================================================================
Case: Squeeze and unsqueeze operations
================================================================================

arraydict=ArrayDict({'data': jnp.ones((5, 1, 3, 1)), 'label': jnp.zeros((5, 1))})
ArrayDict(
    fields={
        data: Tensor(shape=(5, 1, 3, 1), dtype=float32),
        label: Tensor(shape=(5, 1), dtype=float32),
    },
    batch_size=(5, 1))

arraydict.squeeze(1)
ArrayDict(
    fields={
        data: Tensor(shape=(5, 3, 1), dtype=float32),
        label: Tensor(shape=(5,), dtype=float32),
    },
    batch_size=(5,))

arraydict.squeeze(1).unsqueeze(0)
ArrayDict(
    fields={
        data: Tensor(shape=(1, 5, 3, 1), dtype=float32),
        label: Tensor(shape=(1, 5), dtype=float32),
    },
    batch_size=(1, 5))

arraydict.squeeze(1).unsqueeze(0)[0]
ArrayDict(
    fields={
        data: Tensor(shape=(5, 3, 1), dtype=float32),
        label: Tensor(shape=(5,), dtype=float32),
    },
    batch_size=(5,))

================================================================================
Case: Nested structure access and indexing
================================================================================

arraydict=ArrayDict({'outer': jnp.ones((2,3)), 'nested': {'inner1': jnp.zeros((2,3,4)), 'inner2': {'deep': jnp.full((2,3,5), 7.0)}}})
ArrayDict(
    fields={
        nested: ArrayDict(
            fields={
                inner1: Tensor(shape=(2, 3, 4), dtype=float32),
                inner2: {
                    deep: Tensor(shape=(2, 3, 5), dtype=float32),
                },
            },
            batch_size=(2, 3))
        outer: Tensor(shape=(2, 3), dtype=float32),
    },
    batch_size=(2, 3))

arraydict['nested']
ArrayDict(
    fields={
        inner1: Tensor(shape=(2, 3, 4), dtype=float32),
        inner2: {
            deep: Tensor(shape=(2, 3, 5), dtype=float32),
        },
    },
    batch_size=(2, 3))

arraydict['nested', 'inner2']
ArrayDict(
    fields={
        deep: Tensor(shape=(2, 3, 5), dtype=float32),
    },
    batch_size=(2, 3))

arraydict['nested', 'inner2', 'deep']
[[[7. 7. 7. 7. 7.]
  [7. 7. 7. 7. 7.]
  [7. 7. 7. 7. 7.]]

 [[7. 7. 7. 7. 7.]
  [7. 7. 7. 7. 7.]
  [7. 7. 7. 7. 7.]]]

arraydict[0]['nested', 'inner1']
[[0. 0. 0. 0.]
 [0. 0. 0. 0.]
 [0. 0. 0. 0.]]

arraydict[:1]['nested', 'inner2', 'deep']
[[[7. 7. 7. 7. 7.]
  [7. 7. 7. 7. 7.]
  [7. 7. 7. 7. 7.]]]

================================================================================
Case: Stack and concat operations
================================================================================

ad_a=ArrayDict({'x': jnp.array([1.,2.]), 'y': jnp.array([3.,4.])})
ArrayDict(
    fields={
        x: Tensor(shape=(2,), dtype=float32),
        y: Tensor(shape=(2,), dtype=float32),
    },
    batch_size=(2,))

ad_b=ArrayDict({'x': jnp.array([5.,6.]), 'y': jnp.array([7.,8.])})
ArrayDict(
    fields={
        x: Tensor(shape=(2,), dtype=float32),
        y: Tensor(shape=(2,), dtype=float32),
    },
    batch_size=(2,))

stack([ad_a, ad_b], axis=0)
ArrayDict(
    fields={
        x: Tensor(shape=(2, 2), dtype=float32),
        y: Tensor(shape=(2, 2), dtype=float32),
    },
    batch_size=(2, 2))

concat([ad_a, ad_b], axis=0)
ArrayDict(
    fields={
        x: Tensor(shape=(4,), dtype=float32),
        y: Tensor(shape=(4,), dtype=float32),
    },
    batch_size=(4,))

stack([ad_a, ad_b], axis=0)[1]
ArrayDict(
    fields={
        x: Tensor(shape=(2,), dtype=float32),
        y: Tensor(shape=(2,), dtype=float32),
    },
    batch_size=(2,))

concat([ad_a, ad_b], axis=0)[:2]
ArrayDict(
    fields={
        x: Tensor(shape=(2,), dtype=float32),
        y: Tensor(shape=(2,), dtype=float32),
    },
    batch_size=(2,))

================================================================================
Case: Non-numeric fields with indexing
================================================================================

arraydict=ArrayDict({'names': np.array(['Alice','Bob','Charlie'], dtype=object), 'files': np.array([Path('a.txt'),Path('b.txt'),Path('c.txt')], dtype=object), 'scores': jnp.array([95.5,88.0,92.3])})
ArrayDict(
    fields={
        files: PathArray(shape=(3,), content=['a.txt', 'b.txt', 'c.txt']),
        names: StringArray(shape=(3,), content=['Alice', 'Bob', 'Charlie']),
        scores: Tensor(shape=(3,), dtype=float32),
    },
    batch_size=(3,))

arraydict[0]
ArrayDict(
    fields={
        files: PathArray(shape=(), content=['a.txt']),
        names: StringArray(shape=(), content=['Alice']),
        scores: Tensor(shape=(), dtype=float32),
    },
    batch_size=())

arraydict[:2]
ArrayDict(
    fields={
        files: PathArray(shape=(2,), content=['a.txt', 'b.txt']),
        names: StringArray(shape=(2,), content=['Alice', 'Bob']),
        scores: Tensor(shape=(2,), dtype=float32),
    },
    batch_size=(2,))

arraydict[0][None]
ArrayDict(
    fields={
        files: PathArray(shape=(1,), content=['a.txt']),
        names: StringArray(shape=(1,), content=['Alice']),
        scores: Tensor(shape=(1,), dtype=float32),
    },
    batch_size=(1,))

arraydict['names']
['Alice' 'Bob' 'Charlie']

================================================================================
Case: Column insertion (immutable set vs mutable __setitem__)
================================================================================

arraydict=ArrayDict({'x': jnp.ones((2,3))})
ArrayDict(
    fields={
        x: Tensor(shape=(2, 3), dtype=float32),
    },
    batch_size=(2, 3))

arraydict_new = arraydict.set('y', jnp.zeros((2, 3, 4)))
ArrayDict(
    fields={
        x: Tensor(shape=(2, 3), dtype=float32),
        y: Tensor(shape=(2, 3, 4), dtype=float32),
    },
    batch_size=(2, 3))

arraydict  # original unchanged
ArrayDict(
    fields={
        x: Tensor(shape=(2, 3), dtype=float32),
    },
    batch_size=(2, 3))

================================================================================
Case: Mutable column insertion with __setitem__
================================================================================

arraydict=ArrayDict({'x': jnp.ones((2,3))})
arraydict['z'] = jnp.full((2,3,5), 7.0)
ArrayDict(
    fields={
        x: Tensor(shape=(2, 3), dtype=float32),
        z: Tensor(shape=(2, 3, 5), dtype=float32),
    },
    batch_size=(2, 3))

================================================================================
Case: Reshape operations
================================================================================

arraydict=ArrayDict({'data': jnp.arange(24).reshape(2,3,4)})
ArrayDict(
    fields={
        data: Tensor(shape=(2, 3, 4), dtype=int32),
    },
    batch_size=(2, 3, 4))

arraydict.reshape((6, 4))
ArrayDict(
    fields={
        data: Tensor(shape=(6, 4), dtype=int32),
    },
    batch_size=(6, 4))

arraydict.reshape((6, 4))[::2]
ArrayDict(
    fields={
        data: Tensor(shape=(3, 4), dtype=int32),
    },
    batch_size=(3, 4))

================================================================================
Case: Split operations
================================================================================

arraydict=ArrayDict({'x': jnp.arange(30).reshape(6,5), 'y': jnp.ones((6,5,2))})
ArrayDict(
    fields={
        x: Tensor(shape=(6, 5), dtype=int32),
        y: Tensor(shape=(6, 5, 2), dtype=float32),
    },
    batch_size=(6, 5))

parts = arraydict.split(3, axis=0)  # split into 3 parts
[ArrayDict(
    fields={
        x: Tensor(shape=(2, 5), dtype=int32),
        y: Tensor(shape=(2, 5, 2), dtype=float32),
    },
    batch_size=(2, 5)), ArrayDict(
    fields={
        x: Tensor(shape=(2, 5), dtype=int32),
        y: Tensor(shape=(2, 5, 2), dtype=float32),
    },
    batch_size=(2, 5)), ArrayDict(
    fields={
        x: Tensor(shape=(2, 5), dtype=int32),
        y: Tensor(shape=(2, 5, 2), dtype=float32),
    },
    batch_size=(2, 5))]

parts[0]  # first part
ArrayDict(
    fields={
        x: Tensor(shape=(2, 5), dtype=int32),
        y: Tensor(shape=(2, 5, 2), dtype=float32),
    },
    batch_size=(2, 5))

parts[1]  # second part
ArrayDict(
    fields={
        x: Tensor(shape=(2, 5), dtype=int32),
        y: Tensor(shape=(2, 5, 2), dtype=float32),
    },
    batch_size=(2, 5))

================================================================================
Case: Gather operations
================================================================================

arraydict=ArrayDict({'values': jnp.arange(15).reshape(3,5), 'tags': np.array(['a','b','c'], dtype=object)})
ArrayDict(
    fields={
        tags: StringArray(shape=(3,), content=['a', 'b', 'c']),
        values: Tensor(shape=(3, 5), dtype=int32),
    },
    batch_size=(3,))

arraydict.gather(jnp.array([0, 2]), axis=0)
ArrayDict(
    fields={
        tags: StringArray(shape=(2,), content=['a', 'c']),
        values: Tensor(shape=(2, 5), dtype=int32),
    },
    batch_size=(2,))

arraydict.gather(jnp.array([0, 2]), axis=0)['tags']
['a' 'c']

================================================================================
Case: Complex multi-step workflow
================================================================================

arraydict=ArrayDict({'features': jnp.ones((4,3,8)), 'metadata': {'labels': np.array(['cat','dog','bird','fish'], dtype=object), 'ids': jnp.arange(4)}})
ArrayDict(
    fields={
        features: Tensor(shape=(4, 3, 8), dtype=float32),
        metadata: {
            ids: Tensor(shape=(4,), dtype=int32),
            labels: StringArray(shape=(4,), content=['cat', 'dog', 'bird', ...]),
        },
    },
    batch_size=(4,))

step1 = arraydict[:2]  # select first 2 samples
ArrayDict(
    fields={
        features: Tensor(shape=(2, 3, 8), dtype=float32),
        metadata: {
            ids: Tensor(shape=(2,), dtype=int32),
            labels: StringArray(shape=(2,), content=['cat', 'dog']),
        },
    },
    batch_size=(2,))

step2 = step1.unsqueeze(0)  # add batch dimension
ArrayDict(
    fields={
        features: Tensor(shape=(1, 2, 3, 8), dtype=float32),
        metadata: {
            ids: Tensor(shape=(1, 2), dtype=int32),
            labels: StringArray(shape=(1, 2), content=['cat', 'dog']),
        },
    },
    batch_size=(1, 2))

step3 = step2[0, 1]  # index into batch
ArrayDict(
    fields={
        features: Tensor(shape=(3, 8), dtype=float32),
        metadata: {
            ids: Tensor(shape=(), dtype=int32),
            labels: StringArray(shape=(), content=['dog']),
        },
    },
    batch_size=())

step4 = step3['metadata', 'labels']  # access nested field
dog

================================================================================
Case: Deeply nested structure with mixed field types
================================================================================

arraydict=ArrayDict({'numeric': jnp.ones((2,3)), 'level1': {'strings': np.array([['a','b','c'],['d','e','f']], dtype=object), 'level2': {'mixed': np.array([[1,'x',2.5],[2,'y',3.5]], dtype=object), 'paths': np.array([[Path('1.txt'),Path('2.txt'),Path('3.txt')],[Path('4.txt'),Path('5.txt'),Path('6.txt')]], dtype=object)}}})
ArrayDict(
    fields={
        level1: ArrayDict(
            fields={
                level2: {
                    mixed: ObjectArray(shape=(2, 3), dtype=object, types=['float', 'int', 'str']),
                    paths: PathArray(shape=(2, 3), content=['1.txt', '2.txt', '3.txt', ...]),
                },
                strings: StringArray(shape=(2, 3), content=['a', 'b', 'c', ...]),
            },
            batch_size=(2, 3))
        numeric: Tensor(shape=(2, 3), dtype=float32),
    },
    batch_size=(2, 3))

arraydict[0]
ArrayDict(
    fields={
        level1: ArrayDict(
            fields={
                level2: {
                    mixed: ObjectArray(shape=(3,), dtype=object, types=['float', 'int', 'str']),
                    paths: PathArray(shape=(3,), content=['1.txt', '2.txt', '3.txt']),
                },
                strings: StringArray(shape=(3,), content=['a', 'b', 'c']),
            },
            batch_size=(3,))
        numeric: Tensor(shape=(3,), dtype=float32),
    },
    batch_size=(3,))

arraydict['level1', 'level2']
ArrayDict(
    fields={
        mixed: ObjectArray(shape=(2, 3), dtype=object, types=['float', 'int', 'str']),
        paths: PathArray(shape=(2, 3), content=['1.txt', '2.txt', '3.txt', ...]),
    },
    batch_size=(2, 3))

arraydict[1]['level1', 'strings']
['d' 'e' 'f']

arraydict[:, 1]['level1', 'level2', 'paths']
[WindowsPath('2.txt') WindowsPath('5.txt')]

================================================================================
Case: Scalar-like batch operations
================================================================================

arraydict=ArrayDict({'value': jnp.array([42.0]), 'name': np.array(['answer'], dtype=object)}, batch_size=(1,))
ArrayDict(
    fields={
        name: StringArray(shape=(1,), content=['answer']),
        value: Tensor(shape=(1,), dtype=float32),
    },
    batch_size=(1,))

arraydict[0]  # extract single element
ArrayDict(
    fields={
        name: StringArray(shape=(), content=['answer']),
        value: Tensor(shape=(), dtype=float32),
    },
    batch_size=())

arraydict[None]  # add dimension
ArrayDict(
    fields={
        name: StringArray(shape=(1, 1), content=['answer']),
        value: Tensor(shape=(1, 1), dtype=float32),
    },
    batch_size=(1, 1))

arraydict['value']
[42.]

================================================================================
All cases completed successfully!
================================================================================
